# Wireshark 网络分析就这么简单

[toc]

## ARP 回复时并不考虑子网
## 抓包技巧
1. 只抓包头
    - 帧的最大长度为1514字节，启用了 Jumbo Frame （巨型帧）之后可达9000字节以上
    - 单击菜单栏上的 Capture➡️Options➡️定义「Limit each packet to」的值➡️一般设个偏大的数字：80字节，也就是说`每个包只抓前80字节`➡️这样 TCP 层、网络层和数据链路层的信息都可以包括在内
    - 用 `tcpdump` 命令抓包时可以用 `-s` 参数达到相同效果。比如以下命令只抓 `eth0` 上每个包的前 `80` 字节，并把结果存到 `/tmp/tcpdump.cap` 文件中
    
    ```
    #tcpdump -i eth0 -s 80 -w /tmp/tcpdump.cap
    ```
2. 只抓必要的包
    - 只对 IP 为 `10.32.200.131` 的包感兴趣➡️Capture➡️Options➡️Capture Filter中输入`host 10.32.200.131`
    - 对更多 filter 表达式感兴趣，请参考 https://wiki.wireshark.org/CaptureFilters
    - 用 `tcpdump` 命令抓包时，也可以用 `host` 参数达到相同效果。比如以下命令只抓与 `10.32.200.131` 通信的包，并把结果存到 `/tmp/tcpdump.cap` 文件中。

    ```
    #tcpdump -i eth0 host 10.32.200.131 -w /tmp/tcpdump.cap
    ```
1. 抓包步骤
    1. `ping <IP> -n 1 -l 1`
    2. 操作步骤 1
    3. `ping <IP> -n 1 -l 2`
    4. 操作步骤 2
    5. `ping <IP> -n 1 -l 3`
    6. 操作步骤 3

## 个性化设置
1. 调整 Wireshark 时间
    - Wireshark 的 View➡️Time Display Format➡️Date and Time of Day
2. 更改不同类型的网络包的颜色
    - View➡️Coloring Rules
3. 更多的设置可以在 Edit➡️Preferences
    - Protocols➡️TCP就可以看到多个TCP相关选项
4. 时区设置

## 过滤
`ip.addr eq 10.32.106.50 && tcp.port eq 445`
1. 用协议名称过滤
    - `务必考虑协议间的依赖性`
2. IP 地址加 port 号是最常用的过滤方式
    - 右键单击感兴趣的包，选择 Follow TCP/UDP Stream （选择 TCP 还是 UDP 要视传输层协议而定）
    - `单击 Wireshark 的 Statistics➡️Conversations，再单击 TCP 或者 UDP 标签就可以看到所有的 Stream`
3. 用鼠标帮助过滤
    - `右键单击 Wireshark 上感兴趣的内容➡️Prepare a Filter➡️Selected`，就会在 Filter 框中自动生成过滤表达式；在有复杂需求的时候，还可以选择 `And`、`Or` 等选项来生成一个组合的过滤表达式。
    - `假如右键单击之后选择的不是 Prepare a Filter，而是 Apply as Filter➡️Selected，则该过滤表达式生成之后还会自动执行。`
4. 把过滤后得到的网络包存在一个新的文件里
    - `File➡️Save As➡️选中 Displayed 单选按钮再保存`
    - `File➡️Export Specified Packets...`

## 让 Wireshark 自动分析
1. 单击 Wireshark 的 Analyze➡️Expert Info Composite
2. 单击 Statistics➡️Service Response Time➡️选定协议名称，就可以得到响应时间的统计表
    - 我们在衡量服务器性能时经常需要此统计结果
3. 单击 Statistics➡️TCP Stream Graph，就可以生成几类统计图
4. 单击 Statistics➡️Summary，可以看到一些统计信息，比如平均流量等，这有助于我们推测负载状况

## 最容易上手的搜索功能
1. `Carl+F`➡️`String`➡️`Filter`➡️输入`error`进行搜索

## NFS 协议的解析
1. `# rpcinfo -p 10.32.10.6.62 | egrep “portmapper|mountd|nfs”` 获得服务器上的端口列表
2. 再用 `Telnet` 命令逐个试探

## 从 Wireshark 看网络分层
1. 在 TCP 连接建立（三次握手）时，双方都会把自己的 MSS （Maximum Segment Size）告诉对方。MSS 加上 TCP 头和 IP 头的长度，就得到 MTU 了。
    - 在第一个包里，客户端声明自己的 `MSS` 是 `8960`，意味着它的 `MTU` 就是 `8960+20 （TCP头）+ 20（IP头）=9000`。
    - 在第二个包里，服务器声明自己的 `MSS` 是 `1460`，意味着它的 `MTU` 就是`1460+20+20=1500`。
    - `发包的大小是由 MTU 较小的一方决定的。`

## TCP 的 连接启蒙
1. `Seq`：`一个 Seq 号的大小是根据上一个数据段的 Seq 号和长度相加而来的。`
2. `Len`：`TCP中的Len-数据段的长度，不包括 TCP 头。`
3. `ACK`：比如甲方发送了`Seq：x Len：y`的数据段给乙，那乙回复的确认号就是`x+y`，这意味着它收到了`x+y`之前的所有字节。`理论上，接收方回复的 Ack 号恰好就等于发送方的下一个 Seq 号。`
4. `TCP 的确认是可以累积的。`
5. `当包乱序时，接收方只要根据 Seq 号从小到大重新排好就行了，这样就保证了 TCP 的有序性`；`有包丢失时，接收方通过前一个 Seq+Len 的值与下一个 Seq 的差，就能判断缺了哪些包，这保证了 TCP 的可靠性。`
6. TCP 头的标志位
    - `SYN`：携带这个标志的包表示正在发起连接请求。因为连接是双向的，所以建立连接时，双方都要发一个`SYN`。
    - `FIN`：携带这个标志的包表示正在请求终止连接。因为连接时双向的，所以彻底关闭一个连接时，双方都要发一个`FIN`。
    - `RST`：用于重置一个混乱的连接，或者拒绝一个无效的请求。
7. 工作中如果碰到断开连接的问题，可以使用 `netstat` 命令来排查，无论在 `Windows` 还是 `Linux` 上，这个命令都能把当前的连接状态显示出来。

## 快递员的工作策略——TCP 窗口
- 每个包的 TCP 层都含有 `window size：`（也就是win=）的信息。这个值表示发送窗口的大小吗？

> 这不是发送窗口，而是在向对方声明自己的接收窗口。`10.32.106.103` 向 `10.32.106.73` 声明自己的接收窗口是 `64093` 字节。`10.32.106.73` 收到之后，就会把自己的发送窗口限制在 `64093` 字节之内。

> 假如接收方处理数据的速度跟不上接收数据的速度，缓存就会被占满，从而导致接收窗口为 `0`。`89.0.0.85` 持续向 `89.0.0.210` 声明自己的接收窗口是 `win=0`，所以 `89.0.0.210` 的发送窗口就被限制为 `0`，意味着那段时间发不出数据。

- 我如何在包里看出发送窗口的大小呢？

> 很遗憾，没有简单的办法，有时候甚至完全没有办法。因为，当发送窗口是由接收窗口决定的时候，我们还可以通过 `window size：` 的值来判断。而当它由网络因素决定的时候，事情就会变得非常复杂。大多数时候，我们甚至不确定哪个因素在起作用，只能大概推理。

- 发送窗口和 MSS 有什么关系？

> 发送窗口决定了一口气能发多少字节，而 `MSS`决定了这些字节要分多少个包发完。

- 发送方在一个窗口里发出 n 个包，是不是就能收到 n 个确认包？

> 不一定，确认包一般会少一些。由于 `TCP` 可以累积起来确认，所以当收到多个包的时候，只需要确认最后一个就可以了。

- 经常听说 `TCP Window Scale` 这个概念，它究竟和接收窗口有何关系？

> `TCP` 头中只给接收窗口值留了 `16` bit，肯定是无法突破 `65535`（2^16 -1）的。1992年的 RFC 1323 中提出了一个解决方案，就是在三次握手时，把自己的 `Window Scale` 信息告知对方。`Window Scale` 的作用是向对方声明一个 `Shift count`，我们把它作为 `2` 的指数，再乘以 TCP 头中定义的接收窗口，就得到真正的 TCP 接收窗口了。

## 重传的讲究
- `能导致网络拥塞的数据量称为拥塞点`
- 方案1. 发送方知道自己的网卡带宽，能否以此推测该连接的拥塞点？

> 不能。因为发送方和接收方之间还有路由器和交换机，其中任何一个设备都可能是瓶颈。

- 方案2. 逐次增加发送量，直到网络发生拥塞，这样得到的最大发送量能定为该连接的拥塞点吗？

> 这是一个好办法，但没这么简单。网络就像马路一样，有的时候很堵，其他时候却很空。所以拥塞点是一个随时改变的动态值，当前试探出的拥塞点不能代表未来。

- 一个最靠谱的策略

> 这个策略就是在发送方维护一个虚拟的拥塞窗口，并利用各种算法使它尽可能接近真实的拥塞点。==网络对发送窗口的限制，就是通过拥塞窗口实现的。==

- 拥塞窗口如何维护？
    1. 连接刚刚建立的时候，发送方对网络状况一无所知。如果一口气发太多数据就可能遭遇拥塞，所以发送方把拥塞窗口的初始值定得很小。RFC 的建议是 2个、3个或者4个 MSS，具体视 MSS 的大小而定。
    2. 如果发出去的包都得到确认，表明还没有达到拥塞点，可以增大拥塞窗口。由于这个阶段发生拥塞的概率很低，所以增速应该快一些。RFC 建议的算法是每收到 n 个确认，可以把拥塞窗口增加 n 个 MSS。比如发了 2 个包之后收到 2 个确认，拥塞窗口就增大到 2+2=4，接下来是 4+4=8，8+8=16……这个过程的增速很快，但是由于基数低，传输速度还是比较慢的，所以被称为`慢启动过程`。
    3. 慢启动过程持续一段时间后，拥塞窗口达到一个较大的值。这时候传输速度比较快，触碰拥塞点的概率也大了，所以不能继续采用翻倍的慢启动算法，而是要缓慢一点。RFC 建议的算法是在每个往返时间增加 1 个 MSS。比如发了 16 个 MSS之后全部被确认了，拥塞窗口就增加到 16+1=17 个 MSS，再接下去是 17+1=18，18+1=19……这个过程称为`拥塞避免`。从慢启动过渡到拥塞避免的临界窗口值很有讲究。`如果之前发生过拥塞，就把该拥塞点作为参考依据`。如果从来没有拥塞过就可以取相对较大的值，比如`和最大接收窗口相等`。

- 无论是慢启动还是拥塞避免阶段，拥塞窗口都在逐渐增大，理论上一定时间之后总会碰到拥塞点的。那为什么我们平时感觉不到拥塞呢？原因有很多，如下所示：
    1. 操作系统中对接收窗口的最大设定多年没有改动，比如 Windows 在不启动 `TCP window scale option` 的情况下，最大接收窗口只有 `64KB`。而近年来网络有了长足进步，很多环境的拥塞点远在 `64KB` 以上。也就是说发送窗口已经被限制在 `64KB` 了，永远触碰不到拥塞点。
    2. 很多应用场景是交互式的小数据，比如网络聊天，所以也不会有拥塞的可能。
    3. 在传输数据的时候如果采用同步方式，可能需要的窗口非常小。比如采用了同步方式的 NFS 写操作，每发一个写请求就停下来等回复，而一个写请求可能只有 `4KB`。
    4. 即便偶尔发生拥塞，持续时间也不足以长到能感受出来，除非抓了网络包进行数据分析、对比。

- `从发出原始包到重传该包的这段时间称为 RTO。`
- 重传之后的拥塞窗口是否需要调整呢？非常有必要，为了不给刚发生拥塞的网络雪上加霜，`RFC 建议把拥塞窗口降到 1 个 MSS，然后再次进入慢启动过程`。这一次从慢启动过渡到拥塞避免的临界窗口值就有参考依据了。`Richard Stevens 在《TCP/IP Illustrated》中把临界窗口值定为上次发生拥塞时的发送窗口的一半。`而 RFC 5681 则认为应该是发生拥塞时没被确认的数据量的 1/2，但不能小于 2 个 MSS。`比如说发了 19 个包出去，但只有前 3 个包收到确认，那么临界窗口值就被定为后 16 个包携带的数据量的 1/2。`
- 超时重传对传输性能有严重影响。
    1. 在 RTO 阶段不能传数据，相当于浪费了一段时间；
    2. 拥塞窗口的急剧减小，相当于接下来传得慢多了。
- 我们在 Wireshark 中如何检查重传情况呢？
    - 单击 Analyze➡️Expert Info Composite➡️Notes标签查看。
- 有时候拥塞很轻微，只有少量的包丢失。还有些偶然因素，比如校验码不对的时候，会导致单个丢包。这两种丢包症状和严重拥塞时不一样，因为后续有包能正常到达。当后续的包到达接收方时，接收方会发现其 Seq 号比期望的大，所以它每收到一个包就 Ack 一次期望的 Seq 号，以此提醒发送方重传。当发送方收到 3 个或以上重复确认（Dup Ack）时，就意识到相应的包已经丢了，从而立即重传它。这个过程称为`快速重传`。之所以称为快速，是因为它不像超时重传一样需要等待一段时间。
- 为什么要规定凑满 3 个呢？

> `这是因为网络包有时会乱序，乱序的包一样会触发重复的 Ack，但是为了乱序而重传没有必要。`由于一般乱序的距离不会相差太大，比如 2 号包也许会跑到 4 号包后面，但不太可能跑到 6 号包后面，所以限定成 3 个或以上可以在很大程度上避免因乱序而触发快速重传。

- 如果在拥塞避免阶段发生了快速重传，是否需要像发生超时重传一样处理拥塞窗口呢？

> `完全没有必要——既然后续的包都到达了，说明网络并没有严重拥塞，接下来传慢点就可以了。`对此 Richard Stevens 和 RFC 5681 的建议也略有不同。后者认为`临界窗口值应该设为发生拥塞时还没被确认的数据量的 1/2（但不能小于 2 个 MSS）。然后将拥塞窗口设置为临界窗口值加 3 个 MSS，继续保留在拥塞避免阶段。这个过程称为快速恢复。`

- 不知道你是否想到过一个更复杂的情况——很多时候丢的包并不只一个。对于发送方来说，只能通过 Ack 2 知道 2 号包丢失了，但并不知道还有哪些包丢失。在重传了 2 号包之后，接下来应该传哪一个呢？

> 接收方在 Ack 2 号包的时候，顺便把收到的包号告诉发送方。所以这些 Ack 包应该是这样的：
> 收到 4 号包时，告诉发送方：“我已经收到 4 号，请给我 2 号。”
> 收到 5 号包时，告诉发送方：“我已经收到 4、 5 号，请给我 2 号。”
> 收到 6 号包时，告诉发送方：“我已经收到 4、 5、 6号，请给我 2 号。”
> ……
> 因此发送方对丢包细节了如指掌，在快速重传了 2 号包之后，它可以接着传 3 号，然后再传 9 号包。`这个非常直观的方案称为 SACK，由 RFC 2018 定义。`

- 结论
    - ==没有拥塞时，发送窗口越大，性能越好。所以在带宽没有限制的条件下，应该尽量增大接收窗口，比如启用 Scale Option （Windows 上可参考 KB224829）。==
    - ==如果经常发生拥塞，那限制发送窗口反而能提高性能，因为即便万分之一的重传对性能的影响都很大。在很多操作系统上可以通过限制接收窗口的方法来减小发送窗口， Windows 上同样可以参考 KB224829==
    - ==超时重传对性能影响最大，因为它有一段时间（RTO）没有传输任何数据，而且拥塞窗口会被设成 1 个 MSS，所以要尽量避免超时重传。==
    - ==快速重传对性能影响小一些，因为它没有等待时间，而且拥塞窗口减小的幅度没那么大。==
    - ==SACK 和 NewReno 有利于提高重传效率，提高传输性能。==
    - ==丢包对极小文件的影响比大文件严重。因为读写一个小文件需要的包数很少，所以丢包时往往凑不满 3 个 Dup Ack，只能等待超时重传了。而大文件有较大可能触发快速重传。==

## 延迟确认与 Nagle 算法
