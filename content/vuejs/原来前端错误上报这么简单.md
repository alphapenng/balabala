> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s?__biz=MzA4Nzg0MDM5Nw==&mid=2247521293&idx=1&sn=588f9824c862ea35dfc52fc236126b13&chksm=91178a0f0d44ef67ecfd91198fc1454b6562b6ab944010e7f0aabf2c0d20fd4178c3dc3b381e&mpshare=1&srcid=091041vuEEltv7d20JoseiBc&sharer_shareinfo=aef1f9b6b197f70dee5eea4ffeddb9c1&sharer_shareinfo_first=aef1f9b6b197f70dee5eea4ffeddb9c1&from=timeline&scene=2&subscene=1&clicktime=1725948256&enterid=1725948256&sessionid=0&ascene=2&fasttmpl_type=0&fasttmpl_fullversion=7429186-zh_CN-zip&fasttmpl_flag=0&realreporttime=1729130458397&devicetype=android-34&version=28003342&nettype=3gnet&abtest_cookie=AAACAA%3D%3D&lang=zh_CN&countrycode=CN&exportkey=n_ChQIAhIQPh3Jnzc%2B3Ra5ujIlxFp6YxLaAQIE97dBBAEAAAAAADfdCfY9TOcAAAAOpnltbLcz9gKNyK89dVj08wjJ4P7m14yTv6n2uFOHVyjJ45HdaRGeiWZdC%2B9dM3G%2F%2B636p05HYz3PTsmx3E%2F2X3B1W8QL%2FUQxmolxJB4UHxrwk%2FWrcEZa%2FTV%2FvOrZTwbcdidj4DwE6f1wc3EV5UDTvtnLM9sHjzVzlKrx%2BMuXQXAmyZVC4GJ%2BYURLdrp%2FacWazxkHtpT365jdy9qyS0HHUC9UnF%2F21sYeHx6fAYpTdXY%2FMpf8rgnYJsRnspA1gqNzTUi5&pass_ticket=tEvDLWEg3RA%2BAFCmCzr9HEnaFdmLwUgFWOiiEJCqbgemRMmZadmCF1mAXxt53cdZ&wx_header=3)

```
前言

```

项目上线之后，用户如果出现错误（代码报错、资源加载失败以及其他情况），基本上没有办法复现，如果用户出了问题但是不反馈或直接不用了，对开发者或公司来说都是损失。

由于我这个项目比较小，只是一个迷你商城，所以不需要收集很复杂的数据，只需要知道有没有资源加载失败、哪行代码报错就可以了，市面上有很多现成的监控平台比如 sentry，在这里我选择通过 nodejs 自己搭一个服务。

概述
==

我的项目是使用 Vue2 写的，所以本文主要是讲 Vue 相关的部署过程

1、部署后台服务（使用 express）

2、收集前端错误（主要是 Vue）

3、提交信息到后台分析源码位置及记录日志

js 异常处理
=======

```
function test1 () {
    console.log('test1 Start');
    console.log(a);
    console.log('test1 End');
}

function test2 () {
    console.log('test2 Start');
    console.log('test2 End');
}

test1();
test2();


```

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/pfCCZhlbMQSdgO4XoWoZf31ibcZR1hicIyEiaM4rRDX2slZFKVchZmuuyIZ7Nn8JwfG2wPLXNI5uk65t7gHYhB5PQ/640?wx_fmt=other&from=appmsg)

这里可以看到，当 js 运行报错后，代码就不往下执行了，这是因为 js 是单线程，具体可以看看事件循环，这里不做解释

接下来看看使用异步的方式执行，可以看到没有影响代码的继续运行

```
function test1 () {
    console.log('test1 Start');
    console.log(a);
    console.log('test1 End')
}

function test2 () {
    console.log('test2 Start');
    console.log('test2 End')
}

setTimeout(() => {
    test1();
}, 0)

setTimeout(() => {
    test2();
}, 0)


```

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/pfCCZhlbMQSdgO4XoWoZf31ibcZR1hicIyIS1ba0hPicLzW5ic1d1uXUT5n7LWas1RydMmtsjFgXDzR1EEwxsQ36Xg/640?wx_fmt=other&from=appmsg)

那报错之后我们如何收集错误呢？

try catch
---------

```
function test1 () {
    console.log('test1 Start');
    console.log(a);
    console.log('test1 End')
}

try {
  test1();
} catch (e) {
  console.log(e);
}


```

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/pfCCZhlbMQSdgO4XoWoZf31ibcZR1hicIyATFd8IGE23jcILOMQs7NCqXEXk1c5NttdXvdIEVjKh3Q0EvGyJZUiaA/640?wx_fmt=jpeg)

使用 `try catch` 将代码包裹起来之后，当运行报错时，会将收集到的错误传到 catch 的形参中，打印之后我们可以拿到错误信息和错误的堆栈信息，但是 `try catch` 无法捕获到异步的错误

```
function test1 () {
    console.log('test1 Start');
    console.log(a);
    console.log('test1 End')
}

try {
  setTimeout(function() {
    test1();
  }, 100);
} catch (e) {
  console.log(e);
}


```

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/pfCCZhlbMQSdgO4XoWoZf31ibcZR1hicIyYXmnO1FGelGCze2ibzCNeXSpSzWDKianhibuAFMlAIibfpQyKIZhbb4w6Q/640?wx_fmt=other&from=appmsg)

可以看到 `try catch` 是无法捕获到异步错误的，这时候就要用到 `window` 的 `error` 事件

监听 error 事件
-----------

```
window.addEventListener('error', args => {
  console.log(args);
  return true;
}, true)

function test1 () {
    console.log('test1 Start');
    console.log(a);
    console.log('test1 End')
}

setTimeout(function() {
  test1();
}, 100);


```

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/pfCCZhlbMQSdgO4XoWoZf31ibcZR1hicIyYYUMY2PVTNj9d94RWiaxhu7D6ianfWib9caKO1CEFicwpkWVH1bqicGw96g/640?wx_fmt=other&from=appmsg)

除了 `window.addEventListener` 可以监听 `error` 之后，`window.onerror` 也可以监听 `error`，但是 `window.onerror` 和 `window.addEventListener` 相比，无法监听网络异常

### window.addEventListener

```
<img src="https://www.baidu.com/abcdefg.gif">
<script>
  window.addEventListener('error', args => {
    console.log(args);
    return true;
  }, true) // 捕获
</script>


```

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/pfCCZhlbMQSdgO4XoWoZf31ibcZR1hicIyL9B4oiaicgHyiaqoa00ydPS578yKPQaSKJ4Uf1nkuw3fqrIRic8XF0sSaA/640?wx_fmt=other&from=appmsg)

### window.onerror

```
<img src="https://www.baidu.com/abcdefg.gif">
<script>
  window.onerror = function(...args) {
    console.log(args);
  }
</script>


```

由于无法监听到，这里就不放图了

unhandledrejection
------------------

到目前为止，`Promise` 已经成为了开发者的标配，加上新特性引入了 `async await`，解决了回调地狱的问题，但 `window.onerror` 和 `window.addEventListener`，对 `Promise` 报错都是无法捕获

```
window.addEventListener('error', error => {
  console.log('window', error);
})
new Promise((resolve, reject) => {
  console.log(a);
}).catch(error => {
  console.log('catch', error);
})


```

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/pfCCZhlbMQSdgO4XoWoZf31ibcZR1hicIyGPsXVWbibwzNkGwblV2wpfaT5s6NbGtUzeGke1L7BCQ463daddhnPng/640?wx_fmt=other&from=appmsg)

  

可以看到，监听 `window` 上的 `error` 事件是没有用的，可以每一个 `Promise` 写一个 `catch`，如果觉得麻烦，那么就要使用一个新的事件，`unhandledrejection`

```
window.addEventListener('unhandledrejection', error => {
  console.log('window', error);
})
new Promise((resolve, reject) => {
  console.log(a);
})


```

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/pfCCZhlbMQSdgO4XoWoZf31ibcZR1hicIy0FKFwc9I6c43SuicLHjYPmTYBdl3NwhiaKfOiaWx3OPj6Vvica1ZLGkVfw/640?wx_fmt=other&from=appmsg)

其中，`reason` 中存放着错误相关信息，`reason.message` 是错误信息，`reason.stack` 是错误堆栈信息

Promise 错误也可以使用 try catch 捕获到，这里就不做演示了

至此，js 中`同步`、`异步`、`资源加载`、`Promise`、`async/await` 都有相对应的捕获方式

```
window.addEventListener('unhandledrejection', error => {
  console.log('window', error);
  throw error.reason;
})

window.addEventListener('error', error => {
  console.log(error);
  return true;
}, true)


```

vue 异常处理
========

由于我的项目使用 Vue2 搭建的，所以还需要处理一下 vue 的报错

```
export default {
  name: 'App',
  mounted() {
    console.log(aaa);
  }
}


```

现在的项目基本上都是工程化的，通过工程化工具打包出来的代码长这样，上面的代码打包后运行![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/pfCCZhlbMQSdgO4XoWoZf31ibcZR1hicIyMjD4nogrZpTFAdnRDiaBlA3t7cjX4wvwciaffrbbxgnZI1gMhYSV7OOg/640?wx_fmt=other&from=appmsg)

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/pfCCZhlbMQSdgO4XoWoZf31ibcZR1hicIyCbEebTb1iamYVrxVpYWkdYa2IG9RRVOafUEYc89DoWwst4gCyK4L0Yw/640?wx_fmt=other&from=appmsg)

通过报错提示的 js 文件，查看后都是压缩混淆之后的 js 代码，这时候就需要打包时生成的 `source map` 文件了，这个文件中保存着打包后代码和源码对应的位置，我们只需要拿到报错的堆栈信息，通过转换，就能通过 `source map` 找到对应我们源码的文件及出错的代码行列信息

那我们怎么才能监听 `error` 事件呢？

使用 Vue 的全局错误处理函数 `Vue.config.errorHandler`

在 `src/main.js` 中写入以下代码

```
Vue.config.errorHandler = (err, vm, info) => {
  console.log('Error: ', err);
  console.log('vm', vm);
  console.log('info: ', info);
}


```

现在打包 vue 项目

打包 vue 之后然后通过端口访问 `index.html`，不建议你双击打开，如果你没改过打包相关的东西，双击打开是不行的，可以通过 `vs code` 装插件 `live server`，然后将打包文件夹通过 `vs code` 打开

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/pfCCZhlbMQSdgO4XoWoZf31ibcZR1hicIyQkppSwd0MSZhib2H01VzicUx73qfB2wDkYgcUvuUDUqO260UiblTnHia3Q/640?wx_fmt=other&from=appmsg)

上报错误数据
======

经过上述的异常处理后，我们需要将收集到的错误进行整理，将需要的信息发送到后台，我这里选择使用 ajax 发请求到后端，当然你也可以使用创建一个图片标签，将需要发送的数据拼接到 src 上

这里我选择使用 `tracekit` 库来解析错误的堆栈信息，`axios` 发请求，`dayjs` 格式化时间

```
npm i tracekit
npm i axios
npm i dayjs


```

安装完成后在 `src/main.js` 中引入 `tracekit`、`axios`、`dayjs`

上报 Vue 错误
---------

```
import TraceKit from 'tracekit';
import axios from 'axios';
import dayjs from 'dayjs';

const protcol = window.location.protocol;
let errorMonitorUrl = `${protcol}//127.0.0.1:9999`;
const errorMonitorVueInterFace = 'reportVueError'; // vue错误上报接口
TraceKit.report.subscribe((error) => {
  const { message, stack } = error || {};

  const obj = {
    message,
    stack: {
      column: stack[0].column,
      line: stack[0].line,
      func: stack[0].func,
      url: stack[0].url
    }
  };

  axios({
    method: 'POST',
    url: `${errorMonitorUrl}/${errorMonitorVueInterFace}`,
    data: {
      error: obj,
      data: {
        errTime: dayjs().format('YYYY-MM-DD HH:mm:ss'),
        isMobile: /iPhone|iPad|iPod|Android/i.test(navigator.userAgent), // 是否移动端
        isWechat: /MicroMessenger/i.test(navigator.userAgent), // 是否微信浏览器
        isIOS: /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, // 两个都是false就是未知设备
        isAndroid: /Android/.test(navigator.userAgent) && !/Windows Phone/.test(navigator.userAgent)
      },
      browserInfo: {
        userAgent: navigator.userAgent,
        protcol: protcol
      }
    }
  }).then(() => {
    console.log('错误上报成功');
  }).catch(() => {
    console.log('错误上报失败');
  });
});

Vue.config.errorHandler = (err, vm, info) => {
  TraceKit.report(err);
}


```

如果你还需要其他的数据就自己加

打包 vue 之后然后通过端口访问 `index.html`，不建议你双击打开，如果你没改过打包相关的东西，双击打开是不行的，可以通过 `vs code` 装插件 `live server`，然后将打包文件夹通过 `vs code` 打开

现在去项目中看看发出去的请求参数是什么

可以看到我们需要的数据都已经收集到了，上报失败是肯定的，因为我们还没有写好接口

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/pfCCZhlbMQSdgO4XoWoZf31ibcZR1hicIyJK5PllRibwmA5CPQkYoLibPFlt2FHchju4Tia3yDdnAGZJndrA3JE3KiaA/640?wx_fmt=other&from=appmsg)

上报 window 错误
------------

接下来在监听 `window` 的 `error` 事件，也向后台发送一个错误上报请求

```
const errorMonitorWindowInterFace = 'reportWindowError'; // window错误上报接口
window.addEventListener('error', args => {
  const err = args.target.src || args.target.href;
  const obj = {
    message: '加载异常' + err
  };
  if (!err) {
    return true;
  }
  axios({
    method: 'POST',
    url: `${errorMonitorUrl}/${errorMonitorWindowInterFace}`,
    data: {
      error: obj,
      data: {
        errTime: dayjs().format('YYYY-MM-DD HH:mm:ss'),
        isMobile: /iPhone|iPad|iPod|Android/i.test(navigator.userAgent), // 是否移动端
        isWechat: /MicroMessenger/i.test(navigator.userAgent), // 是否微信浏览器
        isIOS: /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, // 两个都是false就是未知设备
        isAndroid: /Android/.test(navigator.userAgent) && !/Windows Phone/.test(navigator.userAgent)
      },
      browserInfo: {
        userAgent: navigator.userAgent,
        protcol: protcol
      }
    }
  }).then(() => {
    console.log('错误上报成功');
  }).catch(() => {
    console.log('错误上报失败');
  });
  return true;
}, true);


```

搭建监控后台
======

创建一个文件夹，名字随便，然后在终端中打开文件夹，初始化 npm

```
npm init -y


```

初始化完成后创建一个 `server.js`，这里我使用 `express` 进行搭建后端，`source-map` 用于解析 `js.map` 文件，这些库后面会用到

```
npm i express
npm i nodemon
npm i source-map


```

下好包之后在 `server.js` 中输入以下代码，然后在终端输入 `nodemon server.js`

```
const express = require('express');
const path = require('path')；
const fs = require('fs');

const PORT = 9999;

const app = express();
app.use(express.urlencoded({ extended: true }))；
app.use(express.json())；

app.get('/', (req, res) => {
  res.send('Hello World!').status(200);
})

app.listen(PORT, () => {
  console.log(`服务启动成功，端口号为:${PORT}`)
})


```

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/pfCCZhlbMQSdgO4XoWoZf31ibcZR1hicIyVS1OqIkuzu2gG67g6m0qNpbssud7JFDE6tM0qUSvFUR9O6vWCbyaAA/640?wx_fmt=other&from=appmsg)

  

服务启动之后，访问本地的 9999 端口，查看是否生效，当看到屏幕上显示 `Hello World!` 表示我们的后端服务成功跑起来了，接下来就是写错误的上传接口

在这里我将为 Vue 和 Window 监控分别写一个接口（因为我懒得一个接口做判断区分，如果你觉得两个接口太麻烦，那你也可以自己优化成一个接口）

编写 Vue 错误上报接口
-------------

在 `server.js` 中继续添加

```
const SourceMap = require('source-map');

app.post('/reportVueError',async (req, res) => {
  const urlParams = req.body;
  console.log(`收到Vue错误报告`);
  console.log('urlParams', urlParams);

  const stack = urlParams.error.stack;
  // 获取文件名
  const fileName = path.basename(stack.url);
  // 查找map文件
  const filePath = path.join(__dirname, 'uploads', fileName + '.map');
  const readFile = function (filePath) {
    return new Promise((resolve, reject) => {
      fs.readFile(filePath, { encoding: 'utf-8'}, (err, data) => {
        if (err) {
          console.log('readFileErr', err)
          return reject(err);
        }
        resolve(JSON.parse(data));
      })
    })
  }

  async function searchSource({ filePath, line, column }) {
    const rawSourceMap = await readFile(filePath);
    const consumer = await new SourceMap.SourceMapConsumer(rawSourceMap);
    const res = consumer.originalPositionFor({ line, column })

    consumer.destroy();
    return res;
  }

  let sourceMapParseResult = '';
  try {
    // 解析sourceMap结果
    sourceMapParseResult = await searchSource({ filePath, line: stack.line, column: stack.column });
  } catch (err) {
    sourceMapParseResult = err;
  }
  console.log('解析结果', sourceMapParseResult)
  res.send({
    data: '错误上报成功',
    status: 200,
  }).status(200);
})


```

然后 `nodemon` 会自动重启服务，如果你不是用 `nodemon` 启动的，那自己手动重启一下

打包 vue 之后然后通过端口访问 `index.html`，不建议你双击打开，如果你没改过打包相关的东西，双击打开是不行的，可以通过 `vs code` 装插件 `live server`，然后将打包文件夹通过 `vs code` 打开，通过 `live server` 运行，此时应该会报跨域问题

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/pfCCZhlbMQSdgO4XoWoZf31ibcZR1hicIySX1SpNzaibUWpjUa43gDZicIkx4RhGp8baA04FGEBDsYVYbicujok34hQ/640?wx_fmt=other&from=appmsg)

设置允许跨域
------

可以自己手动设置响应头实现跨域，我这里选择使用 `cors` 库

```
bash
npm i cors


```

```
const cors = require('cors');
app.use(cors()); // 这条需要放在 const app = express(); 后


```

此时重新运行后台，再观察

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/pfCCZhlbMQSdgO4XoWoZf31ibcZR1hicIy91FtsiaHTxtzUicsuvohQsMklD9rxWD2QvFRr0hYqAmuZl5RIO4Jlmpw/640?wx_fmt=other&from=appmsg)![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/pfCCZhlbMQSdgO4XoWoZf31ibcZR1hicIyOFcqUiaanKOep3BR8xdIbUv7woysibBX8ib9fFwFKVppiaeOCOsjSuhDsA/640?wx_fmt=other&from=appmsg)![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/pfCCZhlbMQSdgO4XoWoZf31ibcZR1hicIyPwSDyPJpuiatne8zG9PEzKq0SvxxsYKzNDUZ8ZDokNibOkQ9yQNTeTbg/640?wx_fmt=other&from=appmsg)

此时发现，解析 map 文件报错了，那是因为我们还没有上传 map 文件

在 `server.js` 同级目录下创建一个 `uploads` 文件夹

回到打包 vue 打包文件目录 `dist`，将 js 文件夹中所有 `js.map` 结尾的文件剪切到创建的文件夹中，如果你打包文件中没有 `js.map`，那是因为你没有打开生成 `js.map` 的开关，打开 `vue.config.js`, 在 `defineConfig` 中设置属性 `productionSourceMap` 为 `true`，然后重新打包就可以了

```
module.exports = defineConfig({
  productionSourceMap: true, // 设置为true，然后重新打包
  transpileDependencies: true,
  lintOnSave: false,
  configureWebpack: {
    devServer: {
      client: false
    }
  }
})


```

> **为什么是剪切？如果真正的项目上线时，你把 `js.map` 文件上传了，别人拿到之后是可以知道你的源码的，所以必须剪切，或者复制之后回到 `dist` 目录删掉所有 `js.map`**

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/pfCCZhlbMQSdgO4XoWoZf31ibcZR1hicIyD9oP1F85kgkVTQFX1z6mQ3ru7mZtPwlTgp5ZXsayo6GfMKWk4Hofzg/640?wx_fmt=other&from=appmsg)

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/pfCCZhlbMQSdgO4XoWoZf31ibcZR1hicIyedXiah5wXTcsTMAIxjNEn2Cwpl9OB4ehgKm7MTjM5K3MeN8lWn7GGnQ/640?wx_fmt=other&from=appmsg)  

这时候我们再刷新网页，然后看后台的输出，显示 `src/App.vue` 的第 10 行有错

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/pfCCZhlbMQSdgO4XoWoZf31ibcZR1hicIytJxkppu15Mjz6dT0OccNXF5ibE7B4EcEsic0qWUcbgFebrQ9RgKSsD8w/640?wx_fmt=other&from=appmsg)

  

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/pfCCZhlbMQSdgO4XoWoZf31ibcZR1hicIyRFIiae3aUKmE5zQ6DiaDQoERkwjiar4aep0v9A6zYiaicMLOibPe9XGAV4EQ/640?wx_fmt=other&from=appmsg)

  

编写 window 错误上传接口
----------------

```
// 处理Window报错
app.post('/reportWindowError',async (req, res) => {
  const urlParams = req.body;
  console.log(`收到Window错误报告`);
  console.log('urlParams', urlParams);

  res.send({
    data: '错误上报成功',
    status: 200,
  }).status(200);
})


```

此时我们去 vue 项目中添加一个 img 标签，获取一张不存在的图片即可出发错误，由于不用解析，所以这里就不再上传 `js.map` 了

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/pfCCZhlbMQSdgO4XoWoZf31ibcZR1hicIygYK9qSKwMVb5qjXTib5Qzwubdk0xxkYS6k7D6Z6rf3iaycqI7ibQ9slicA/640?wx_fmt=other&from=appmsg)

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/pfCCZhlbMQSdgO4XoWoZf31ibcZR1hicIyNSTFa2mHTvWj7CnWL3ZkBIwJTpXhz1Vc3CERzJLVbJgKicUnJfqrdSQ/640?wx_fmt=other&from=appmsg)

  

写入日志
----

错误上报之后我们需要记录下来，接下来我们改造一下接口，收到报错之后写一下日志

我需要知道哪一天的日志报错了，所有我在 node 项目中也下载 `dayjs` 用来格式化时间

```
npm i dayjs


```

此处的日志记录内容只是我自己需要的格式，如果你需要其他格式请自己另外添加

### vue 错误写入日志

```
// let sourceMapParseResult = '';
// try {
//  // 解析sourceMap结果
//  sourceMapParseResult = await searchSource({ filePath, line: stack.line, column: //stack.column });
//} catch (err) {
//  sourceMapParseResult = err;
//}
//console.log('解析结果', sourceMapParseResult)

// 直接将下面的内容粘贴在上面的log下面

const today = dayjs().format('YYYY-MM-DD') // 今天

const logDirPath = path.join(__dirname, 'log');
const logFilePath = path.resolve(__dirname, 'log/' + `log-${today}.txt`)

if (!fs.existsSync(logDirPath)) {
  console.log(`创建log文件夹`)
  fs.mkdirSync(logDirPath, { recursive: true });
}
if (!fs.existsSync(logFilePath)) {
  console.log(`创建${today}日志文件`)
  fs.writeFileSync(logFilePath, '', 'utf8');
}

const writeStream = fs.createWriteStream(logFilePath, { flags: 'a' });
writeStream.on('open', () => {
  // writeStream.write('UUID：' + urlParams.data.uuid + '\n');
  writeStream.write('错误类型：Window' + '\n');
  writeStream.write('错误发生时间：' + urlParams.data.errTime + '\n');
  writeStream.write('IP：' + req.ip + '\n');
  writeStream.write(`安卓: ${urlParams.data.isAndroid} IOS: ${urlParams.data.isIOS} 移动端: ${urlParams.data.isMobile} 微信: ${urlParams.data.isWechat} （安卓和ios同时为false表示未知设备）` + '\n');
  writeStream.write('用户代理：' + urlParams.browserInfo.userAgent + '\n');
  writeStream.write('错误信息：' + urlParams.error.message + '\n');
  writeStream.write('---------------------------------- \n');

  writeStream.end(() => {
    console.log('vue错误日志写入成功');
    console.log('---------------------');
    res.send({
      data: '错误上报成功',
      status: 200,
    }).status(200);
  });
})

writeStream.on('error', err => {
  res.send({
    data: '错误上报失败',
    status: 404,
  }).status(404);
  console.error('发生错误:', err);
})


```

### window 错误写入日志

和 vue 写入的方式差不多，存在优化空间

```
const today = dayjs().format('YYYY-MM-DD') // 今天

const logDirPath = path.join(__dirname, 'log');
const logFilePath = path.join(__dirname, 'log' + `/log-${today}.txt`)

if (!fs.existsSync(logDirPath)) {
  console.log(`创建log文件夹`)
  fs.mkdirSync(logDirPath, { recursive: true });
}
if (!fs.existsSync(logFilePath)) {
  console.log(`创建${today}日志文件`)
  fs.writeFileSync(logFilePath, '', 'utf8');
}

const writeStream = fs.createWriteStream(logFilePath, { flags: 'a' });
writeStream.on('open', () => {
  writeStream.write('错误类型：Window' + '\n');
  writeStream.write('错误发生时间：' + urlParams.data.errTime + '\n');
  writeStream.write('IP：' + req.ip + '\n');
  writeStream.write(`安卓: ${urlParams.data.isAndroid} IOS: ${urlParams.data.isIOS} 移动端: ${urlParams.data.isMobile} 微信: ${urlParams.data.isWechat} （安卓和ios同时为false表示未知设备）` + '\n');
  writeStream.write('用户代理：' + urlParams.browserInfo.userAgent + '\n');
  writeStream.write('错误信息：' + urlParams.error.message + '\n');
  writeStream.write('---------------------------------- \n');

  writeStream.end(() => {
    console.log('window错误日志写入成功');
    console.log('---------------------');
    res.send({
      data: '错误上报成功',
      status: 200,
    }).status(200);
  });
})

writeStream.on('error', err => {
  res.send({
    data: '错误上报失败',
    status: 404,
  }).status(404);
  console.error('发生错误:', err);
})


```

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/pfCCZhlbMQSdgO4XoWoZf31ibcZR1hicIyt5gQSOibm074ficEMpCjdmyKd11OzU6b4LOHicwbDqqacF7RzQNuYt6Tw/640?wx_fmt=other&from=appmsg)

  

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/pfCCZhlbMQSdgO4XoWoZf31ibcZR1hicIyH5LXrjuJNT2o7nAGlSI4NAB94micdIicDYxQUnCk3sJibkYzQWt5pDlHQ/640?wx_fmt=other&from=appmsg)

  

至此，收集错误，上报错误，写入日志已经全部完成。

其他
==

错误监控持久化运行在服务器
-------------

这个可以使用 `pm2`，在服务器上使用 node 全局安装 `pm2` 库

```
pm2 ls #显示所有pm2启动的应用
pm2 start /xxx/xxx # 启动/xxx/xxx应用
pm2 save # 保存当前应用列表
pm2 stop id # id 通过pm2 ls查看
pm2 logs id # 查看日志


```

自动上传 `js.map` 文件
----------------

如果每次打包后都手动复制 `js.map` 文件的到 `uploads` 文件夹下，似乎有些麻烦

虽然麻烦，但是我自己还是没有自动上传，原因是如果打包就自动上传，那么如果项目还未发布，但是文件已经替换掉之前的文件了，新版本未发布之前，vue 的错误就无法解析了，当然，如果你每次上传都不删除以前的文件也是可以的

### 修改 vue 项目

在 vue 项目 `src` 下创建一个 `plugin` 目录，新建一个 `UploadSourceMap.js`，将下面的代码粘贴进去

```
const glob = require('glob')
const path = require('path')
const http = require('http')
const fs = require('fs')

class UploadSourceMap {
  constructor (options) {
    this.options = options
  }

  apply (compiler) {
    console.log('UploadSourceMap')

    // 在打包完成后运行
    compiler.hooks.done.tap('UploadSourceMap', async stats => {
      const list = glob.sync(path.join(stats.compilation.outputOptions.path, '**/*.js.map'))
      for (const item of list) {
        const fileName = path.basename(item);
        console.log(`开始上传${fileName}`)
        await this.upload(this.options.url, item)
        console.log(`上传${fileName}完成`)
      }
    })
  }

  upload (url, file) {
    return new Promise((resolve, reject) => {
      const req = http.request(
        `${url}/upload?name=${path.basename(file)}`,
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/octet-stream',
            Connection: 'keep-alive',
            'Transfer-Encoding': 'chunked'
          }
        }
      )
      fs.createReadStream(file)
        .on('data', chunk => {
          req.write(chunk)
        })
        .on('end', () => {
          req.end()
          // 删除文件
          fs.unlink(file, (err) => {
            if (err) {
              console.error(err)
            }
          })
          resolve()
        })
    })
  }
}

module.exports = UploadSourceMap


```

修改 `vue.config.js`

主要是引入 `UploadSourceMap`，并且在 `configureWebpack` => `plugins` 下使用

```
const { defineConfig } = require('@vue/cli-service')
const UploadSourceMap = require('./src/plugin/UploadSourceMap')

module.exports = defineConfig({
  productionSourceMap: true,
  transpileDependencies: true,
  lintOnSave: false,
  configureWebpack: {
    plugins: [
      new UploadSourceMap({
        url: 'http://127.0.0.1:9999' // 后面换成自己的服务器地址
      })
    ]
  }
})


```

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/pfCCZhlbMQSdgO4XoWoZf31ibcZR1hicIyCYia7We9f3rL8SekTviclnXSwMGKx2icbQrN0ibg2FWSHiajageXSFicJnXQ/640?wx_fmt=other&from=appmsg)

  

### 修改后台

修改 `server.js`，新增一个上传文件的接口

```
app.post('/upload', (req, res) => {
  const fileName = req.query.name
  const filePath = path.join(__dirname, 'uploads', fileName)

  if (!fs.existsSync(path.dirname(filePath))) {
    fs.mkdirSync(path.dirname(filePath), { recursive: true })
  }

  const writeStream = fs.createWriteStream(filePath)

  req.on('data', (chunk) => {
    writeStream.write(chunk)
  })

  req.on('end', () => {
    writeStream.end(() => {
      res.status(200).send(`File ${fileName} has been saved.`)
    })
  })

  writeStream.on('error', (err) => {
    fs.unlink(filePath, () => {
      console.error(`Error writing file ${fileName}: ${err}`)
      // res.status(500).send(`Error writing file ${fileName}.`)
    })
  })
})


```

然后现在重新打包，观察打包输出

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/pfCCZhlbMQSdgO4XoWoZf31ibcZR1hicIyPp8JtN4jqx59gSVOVA2pUx8Dj41RX8XfluNViaKbsBzeo8DvtB9nic6Q/640?wx_fmt=other&from=appmsg)

最后
==

尽量是不要开启跨域，否则谁都能给发请求到后台，如果要开跨域，那需要做好判断，主域名不符合的直接返回 404 终止这次请求。

市面上的监控有很多，有些甚至能实现录制用户操作生成 gif，本文只是实现一个基本的错误监控，如有错误请指出。

源码参考：https://github.com/liuxulin0626/error-monitor-demo

**原文地址：https://juejin.cn/post/7383955****685368086562**

**作者：用户不会像你这么操作的**

如有错误，欢迎指正。